diff --git a/.gitignore b/.gitignore
index 2eb6846..6f0d569 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,8 @@ __pycache__/
 *.py[cod]
 *$py.class
 
+main.py
+
 # C extensions
 *.so
 *.c
diff --git a/README.md b/README.md
index b9e1a83..9295ba0 100644
--- a/README.md
+++ b/README.md
@@ -26,6 +26,16 @@ Below are examples demonstrating the functions provided by the 'rut' module.
     else:
         print("Invalid RUT")
 
+### Using Suspicious RUT
+
+    from pyrut import validate_rut
+
+    # Validate RUT using the Cython implementation
+    if validate_rut("210496157", suspicious=true):
+        print("Valid RUT")
+    else:
+        print("Invalid RUT")
+
 ### Formatting a RUT
 
     from pyrut import format_rut
@@ -42,6 +52,14 @@ Below are examples demonstrating the functions provided by the 'rut' module.
     digit = verification_digit("21049615")
     print("Verification Digit:", digit)
 
+### Using list of RUTs
+
+    from pyrut import  validate_list_ruts
+
+    # Validate a list of RUTs using the Cython implementation
+    ruts = ["11111111-1"] * 10000
+    valid_ruts = validate_list_ruts(ruts, suspicious=True)
+    print("Valid RUTs:", valid_ruts)
 
 ### Using Type
 
@@ -50,10 +68,15 @@ Below are examples demonstrating the functions provided by the 'rut' module.
 
     app = FastAPI()
 
-    @app.get("/persona-c/{rut}")
+    @app.get("/person/{rut}")
     async def root(rut: Rut):
         return {"message": "Hello World", "rut": rut}
 
+    @app.get("/person/{not-suspicious-rut}")
+    async def root(rut: RutNotSuspicious):
+        return {"message": "Hello World", "rut": rut}
+
+
 
 ## Documentation
 
@@ -64,7 +87,7 @@ Detailed module documentation is available in the docs directory. See docs/index
 Unit tests are located in the tests directory. Run them using a testing framework like pytest:
 
     pytest pyrut/tests
-    
+
 
 
 ## Contributing
diff --git a/bench/http/main.py b/bench/http/main.py
index 33ae3ee..f18e82a 100644
--- a/bench/http/main.py
+++ b/bench/http/main.py
@@ -1,5 +1,5 @@
 from fastapi import FastAPI
-from pyrut.types import RutStr
+from pyrut.types import Rut
 from itertools import cycle
 from pydantic import BeforeValidator
 from typing import Annotated
@@ -34,7 +34,7 @@ app = FastAPI()
 RutPy = Annotated[str, BeforeValidator(validar_rut)]
 
 @app.get("/persona-c/{rut}")
-async def rutcython(rut: RutStr):
+async def rutcython(rut: Rut):
     return {"message": "Hello World", "rut": rut}
 
 @app.get("/persona-p/{rut}")
diff --git a/main.py b/main.py
deleted file mode 100644
index cb1a81c..0000000
--- a/main.py
+++ /dev/null
@@ -1 +0,0 @@
-from pyrut import validate_rut
diff --git a/pyrut/__init__.py b/pyrut/__init__.py
index e69de29..cb58244 100644
--- a/pyrut/__init__.py
+++ b/pyrut/__init__.py
@@ -0,0 +1,15 @@
+from .rut import (
+    validate_rut,
+    validate_rut_string,
+    format_rut,
+    verification_digit,
+    validate_list_ruts
+)
+
+__all__ = [
+    'validate_rut',
+    'validate_rut_string',
+    'format_rut',
+    'verification_digit',
+    'validate_list_ruts'
+]
diff --git a/pyrut/rut.pyx b/pyrut/rut.pyx
index f9235ce..043c056 100644
--- a/pyrut/rut.pyx
+++ b/pyrut/rut.pyx
@@ -1,43 +1,81 @@
-# distutils: language = c
-# cython: language_level=3, boundscheck=False, wraparound=False, cdivision=True
+# cython: language_level=3, boundscheck=False, wraparound=False, infer_types=True
 
-from libc.stdint cimport uint16_t, uint8_t, uint64_t
+
+from libc.stdint cimport uint16_t
 from libc.stddef cimport size_t
 from libc.stdlib cimport malloc, free
-from cpython.bytes cimport PyBytes_AsString, PyBytes_AsStringAndSize
+from cpython.bytes cimport PyBytes_AsString
 from libc.stdlib cimport free
-from cpython.unicode cimport PyUnicode_FromStringAndSize
+from cpython.unicode cimport PyUnicode_FromStringAndSize, PyUnicode_AsUTF8String
 from libc.string cimport strlen
+from cpython.list cimport PyList_GET_SIZE
+
+
+from cpython.list cimport PyList_GET_SIZE
+
 
 
-cpdef bint validate_rut(str input_rut):
+
+cdef inline char* encode(str r) noexcept:
+    cdef:
+        bytes b = PyUnicode_AsUTF8String(r)
+        char *data = PyBytes_AsString(b)
+    return data
+
+cpdef bint validate_rut(str input_rut, bint suspicious=False):
     """
     Valida un solo RUT (str) y devuelve True/False.
     """
-    cdef bytes b = input_rut.encode('utf-8')
-    cdef char *data = PyBytes_AsString(b)
-    cdef bint result = _validate_rut(data)
-
+    cdef char* data = encode(input_rut)
+    cdef bint result = _validate_rut(data, suspicious)
     return result
 
 
+cpdef list validate_list_ruts(list ruts, bint suspicious=False):
+    """
+    Valida una lista de RUTs (list) y devuelve una lista de True/False.
+    """
+    cdef:
+        Py_ssize_t len_list = PyList_GET_SIZE(ruts)
+        bint is_valid
+
+    for i in range(len_list):
+
+        rut = encode(ruts[i])
+        is_valid = _validate_rut(rut, suspicious)
+        if not is_valid:
+            ruts[i] = False
+
+    return ruts
+
+cpdef validate_rut_string(str v, bint suspicious=False):
+    cdef:
+        char* data = encode(v)
+        bint result = _validate_rut(data, suspicious)
+
+    if result:
+        return v
+    else:
+        raise ValueError("Invalid RUT")
+
+
 cpdef str format_rut(str rut, bint dots=True, bint uppercase=True, bint ignore_invalid=False):
     """
     Formatea un RUT (str) con puntos y guión.
     """
-    cdef bytes b = rut.encode('utf-8')
-    cdef char *data = PyBytes_AsString(b)
+    cdef char *data = encode(rut)
     cdef char *formatted_rut = format_rut_c(data, dots, uppercase, ignore_invalid)
+
     cdef str result = formatted_rut.decode('utf-8')
     free(formatted_rut)
     return result
 
 
-
 cdef char* format_rut_c(const char* rut,
                         bint dots,
                         bint uppercase,
                         bint ignore_invalid):
+
     cdef const char* p = rut
     cdef char c, dv_char = 0
     cdef Py_ssize_t total_valid = 0
@@ -45,30 +83,26 @@ cdef char* format_rut_c(const char* rut,
     cdef char* out
     cdef char* dst
     cdef Py_ssize_t ndots = 0
-
+    cdef size_t len_rut = strlen(rut)
     # ——————————————
     # 1) Primer pase: contar dígitos + capturar DV
     # ——————————————
-    for i in range(strlen(rut)):
+    for i in range(len_rut):
         c = p[i]
-        if b'0' <= c <= b'9' or c == b'K' or c == b'k':
+        if '0' <= c <= '9' or c == 'K' or c == 'k':
             dv_char = c
             total_valid += 1
-        elif c == b'.' or c == b'-' or c == b' ':
+        elif c == '.' or c == '-' or c == ' ':
             continue
         else:
             if not ignore_invalid:
                 return NULL
 
     if total_valid < 2:
-        return NULL
+        return b''
 
     body_len = total_valid - 1
 
-    #    forzar mayúscula vía bitmasking (más rápida que rama)
-    if uppercase:
-        dv_char &= 0xDF  # convierte 'k' a 'K' si procede
-
     if dots:
         ndots = (body_len - 1) // 3
 
@@ -77,7 +111,7 @@ cdef char* format_rut_c(const char* rut,
 
     out = <char*> malloc(out_len)
     if not out:
-        return NULL
+        return b""
 
     # ——————————————
     # 3) Segundo pase: construir la cadena formateada
@@ -85,48 +119,56 @@ cdef char* format_rut_c(const char* rut,
     dst = out
     total_valid = 0  # reusar como contador de dígitos emitidos
 
-    for i in range(strlen(rut)):
+    for i in range(len_rut):
         c = p[i]
-        if b'0' <= c <= b'9' or c == b'K' or c == b'k':
+        if '0' <= c <= '9' or c == 'K' or c == 'k':
             if total_valid < body_len:
-                # insertar punto si toca
+                # insertar punto si corresponde
                 if dots and total_valid > 0 and ((body_len - total_valid) % 3) == 0:
-                    dst[0] = b'.'; dst += 1
-
-                # emitir dígito o 'K'/'k'
-                if (c == b'K' or c == b'k'):
+                    dst[0] = '.'; dst += 1
+                if c == 'K' or c == 'k':
                     if uppercase:
-                        dst[0] = b'K'
+                        dst[0] = 'K'
                     else:
-                        dst[0] = b'k'
+                        dst[0] = 'k'
                 else:
                     dst[0] = c
                 dst += 1
 
             total_valid += 1
 
-    # añadir guión, dígito verificador y terminador
-    dst[0] = b'-'; dst += 1
-    dst[0] = dv_char; dst += 1
-    dst[0] = b'\0'
+
+    dst[0] = '-';
+    dst += 1;
+    if dv_char == 'K' or dv_char == 'k':
+        if uppercase:
+            dst[0] = 'K'
+        else:
+            dst[0] = 'k'
+    else:
+        dst[0] = dv_char
+
+    dst += 1;
+    dst[0] = '\0';
 
     return out
 
-cdef inline uint8_t compute_dv_from_int(uint64_t body) nogil:
+
+cdef inline int compute_dv_from_int(int body) nogil:
     """
     Calcula el dígito verificador de un RUT dado como entero (sin DV).
     Devuelve:
         - 0–9 para DV '0'–'9'
         - 10 para DV 'K'
     """
-    cdef uint64_t n = body
+    cdef int n = body
     cdef int total = 0
     cdef int mul = 2
     cdef int digit
 
     # Recorrer dígitos de derecha a izquierda
     while n > 0:
-        digit = <int>(n % 10)
+        digit = (n % 10)
         total += digit * mul
         mul = mul + 1 if mul < 7 else 2
         n //= 10
@@ -137,19 +179,20 @@ cdef inline uint8_t compute_dv_from_int(uint64_t body) nogil:
     elif m == 10:
         return 10   # equivale a 'K'
     else:
-        return m
+        return 48 + m
 
 cdef inline str _verification_digit_from_int(int dv):
     cdef char dv_char
     if dv == 11:
-        dv_char = b'0'
+
+        return '0'
     elif dv == 10:
-        dv_char = b'K'
+        return 'K'
+    elif dv == 0:
+        return '0'
     else:
-        dv_char = <char>(dv + 0)  # 48 == ord('0')
-
-
-    return PyUnicode_FromStringAndSize(&dv_char, 1)
+        dv_char = <char>(dv)
+        return PyUnicode_FromStringAndSize(&dv_char, 1)
 
 
 cpdef str verification_digit(rut):
@@ -159,54 +202,62 @@ cpdef str verification_digit(rut):
         - 10 para 'K'
     Acepta `rut` como str (sin DV) o como int (sin DV).
     """
+
     cdef char *data
-    cdef Py_ssize_t length
     cdef int dv
-    cdef bytes b
+    cdef char *b
+    cdef char dv_char
 
+    cdef char cleaned[99]
+    cdef size_t length
     if isinstance(rut, str):
         # 1) codifica a bytes y extrae buffer + longitud
-        b = rut.encode('utf-8')
-        if PyBytes_AsStringAndSize(b, &data, &length) != 0:
-            raise ValueError("Error al codificar RUT a bytes")
-        # 2) calcula DV sobre la cadena
-        dv = compute_dv(data, <size_t>length)
+        b = encode(rut)
+        clean_rut(b, cleaned)
+        if cleaned[0] == b'\0':
+            raise ValueError("RUT inválido")
 
-        return _verification_digit_from_int(dv)
+        # Longitud del RUT limpio
+        length = strlen(cleaned)
+        if length < 1:
+            raise ValueError("RUT inválido")
 
-    elif isinstance(rut, int):
-        # 3) convierte el entero a uint64_t y calcula DV
-        dv = compute_dv_from_int(<uint64_t>rut)
 
+        dv_char = compute_dv(b)
+        return PyUnicode_FromStringAndSize(&dv_char, 1)
+
+    elif isinstance(rut, int):
+        dv = compute_dv_from_int(rut)
         return _verification_digit_from_int(dv)
 
     else:
         raise TypeError(f"Tipo no válido: {type(rut).__name__}")
 
-
-cdef inline char compute_dv(char *s, size_t body_len) nogil:
-    cdef uint16_t total = 0
+cdef inline char compute_dv(char *s) noexcept nogil:
+    cdef int total = 0
     cdef uint16_t m
     cdef int mul = 2
-    cdef size_t i = body_len
-    # recorrer de derecha a izquierda sin usar range
+    cdef size_t i = strlen(s)
     while i > 0:
         i -= 1
-        total += (s[i] - 48) * mul  # '0' -> 48
+        total += (s[i] - 48) * mul  # '0' == 48
         if mul < 7:
             mul += 1
         else:
             mul = 2
+
     m = 11 - (total % 11)
     if m == 11:
-        return <char>48  # '0'
+        return b'0'
     elif m == 10:
-        return <char>75  # 'K'
+        return <char>75
     else:
-        return <char>(48 + m)
+        return <char>(m + 48)
 
-cdef inline void clean_rut(const char* src, char* dst) nogil:
+cdef inline void clean_rut(const char* src, char* dst) noexcept nogil:
     cdef char c
+    cdef int points = 0
+    cdef int g = 0
     while True:
         c = src[0]
         if c == b'\0':
@@ -218,7 +269,22 @@ cdef inline void clean_rut(const char* src, char* dst) nogil:
         elif c == b'K' or c == b'k':
             dst[0] = b'K'
             dst += 1
-        elif c == b'.' or c == b'-' or c == b' ':
+        elif c == b'.':
+
+            if points > 1:
+                # más de un punto, limpiar salida
+                dst[0] = b'\0'
+                return
+            points += 1
+        elif c == b'-':
+
+            if g > 1:
+                # más de un guión, limpiar salida
+                dst[0] = b'\0'
+                return
+            g += 1
+        elif c == b' ':
+            # espacio en blanco, ignorar
             continue
         else:
             # carácter inválido, limpiar salida
@@ -226,9 +292,39 @@ cdef inline void clean_rut(const char* src, char* dst) nogil:
             return
     dst[0] = b'\0'
 
-cdef bint _validate_rut(char *s):
+
+cdef inline bint is_suspicious(char* s) noexcept nogil:
+    """
+    Devuelve True si todos los caracteres en s (hasta '\0')
+    son iguales entre sí. Si la cadena está vacía (s[0] == '\0'),
+    se considera que cumple (devuelve True).
+    """
+    cdef char first = s[0]
+    cdef char c
+
+    # Si la cadena está vacía, asumimos que "todos los caracteres son iguales"
+    if first == b'\0':
+        return True
+
+    # Avanzamos un puntero para comparar el resto
+    s += 1
+    while True:
+        c = s[0]
+        if c == b'\0':
+            break
+        if c != first:
+            return False
+        s += 1
+
+    return True
+
+
+
+cdef bint _validate_rut(char *s, bint suspicious) :
     cdef const char *src = s
-    cdef char cleaned[99]  # Buffer de salida, tamaño suficiente para un RUT
+    cdef char cleaned[20]  # Buffer de salida, tamaño suficiente para un RUT
+    cdef bint valid = True
+    cdef char dv
     clean_rut(src, cleaned)
 
     # Verifica si el resultado quedó vacío (fallo por carácter inválido)
@@ -237,10 +333,16 @@ cdef bint _validate_rut(char *s):
 
     # Longitud del RUT limpio
     cdef size_t length = strlen(cleaned)
-    if length < 2:
+    if length < 1:
         return False
+    dv = <char>(cleaned[length - 1])
+    cleaned[length-1] = '\0'
+    if suspicious:
+        valid = is_suspicious(cleaned)
+        if valid:
+            return False
+
+    cdef char expected = compute_dv(cleaned)
 
-    # Validación del dígito verificador
-    cdef char expected = compute_dv(cleaned, length - 1)
 
-    return cleaned[length - 1] == expected
+    return dv == expected
diff --git a/pyrut/types/__init__.py b/pyrut/types/__init__.py
index 2c35e3b..cbcab11 100644
--- a/pyrut/types/__init__.py
+++ b/pyrut/types/__init__.py
@@ -1,6 +1,8 @@
 from typing import Annotated
 from pydantic import BeforeValidator
+from functools import partial
 
-from .rut import validate_rut_string
+from pyrut import validate_rut_string
 
-Rut = Annotated[str, BeforeValidator(validate_rut_string)]
+Rut = Annotated[str, BeforeValidator(partial(validate_rut_string, suspicious=False))]
+RutNotSuspicious = Annotated[str, BeforeValidator(partial(validate_rut_string, suspicious=True))]
diff --git a/pyrut/types/rut.py b/pyrut/types/rut.py
deleted file mode 100644
index 3a00b60..0000000
--- a/pyrut/types/rut.py
+++ /dev/null
@@ -1,7 +0,0 @@
-from py_rut import validate_rut
-
-def validate_rut_string(v: str) -> str:
-    if validate_rut(v):
-        return v
-    else:
-        raise ValueError(f"Invalid RUT: {v}")
diff --git a/setup.py b/setup.py
index b2cd810..b11304f 100644
--- a/setup.py
+++ b/setup.py
@@ -2,20 +2,21 @@ from setuptools import setup, Extension, find_packages
 from Cython.Build import cythonize
 import pathlib
 
+
 here = pathlib.Path(__file__).parent
 
 extensions = [
     Extension(
-        "pyrut",
+        "pyrut.rut",
         sources=["pyrut/rut.pyx"],
         extra_compile_args=["-O3", "-march=native"],
-        language="c"
+        language="c",
     ),
 ]
 
 setup(
     name="PyRut",
-    version="1.0.5",
+    version="1.1.0",
     description="High-performance Chilean RUT validation & formatting (Cython)",
     long_description=here.joinpath("README.md").read_text(encoding="utf-8"),
     long_description_content_type="text/markdown",
@@ -32,4 +33,5 @@ setup(
     ],
     python_requires=">=3.8",
     zip_safe=False,
+
 )
diff --git a/tests/__init__.py b/tests/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests/rut_test.py b/tests/rut_test.py
index 86d3dd2..4eea17d 100644
--- a/tests/rut_test.py
+++ b/tests/rut_test.py
@@ -1,22 +1,323 @@
 import pytest
-from pyrut import validate_rut, format_rut, verification_digit
-
-def test_validate_rut_valid():
-    # Se espera que este RUT sea válido
-    assert validate_rut("210496157") == True
-
-def test_validate_rut_invalid():
-    # Asumimos que un RUT con ceros no es válido
-    assert validate_rut("000000000") == False
-
-def test_format_rut():
-    # Se espera que al formatear "21049615-7" se obtenga "21.049.615-7"
-    formatted = format_rut("21049615-7", dots=True)
-    expected = "21.049.615-7"
-    assert formatted == expected
-
-def test_verification_digit():
-    # Se espera que el dígito verificador para "21049615" sea "6"
-    digit = verification_digit("21049615")
-    expected = "7"
-    assert digit == expected
+import pyrut
+from pyrut.types import Rut, RutNotSuspicious
+from pydantic import ValidationError
+
+
+class TestValidateRut:
+    """Tests for validate_rut function"""
+
+    def test_valid_ruts(self):
+        """Test with valid RUTs in different formats"""
+        valid_ruts = [
+            "11.111.111-1",
+            "11111111-1",
+            "111111111",
+            "12.345.678-5",
+            "12345678-5",
+            "123456785",
+        ]
+
+        for rut in valid_ruts:
+            assert pyrut.validate_rut(rut), f"RUT {rut} should be valid"
+
+    def test_invalid_ruts(self):
+        """Test with invalid RUTs"""
+        invalid_ruts = [
+            "11.111.111-2",  # Wrong check digit
+            "12.345.678-6",  # Wrong check digit
+            "7.654.321-J",   # Invalid check digit
+            "123456789",     # Wrong length
+            "1234567",       # Too short
+            "12345678901",   # Too long
+            "",              # Empty string
+            "abcdefgh-i",    # Non-numeric body
+            "12.34x.678-5",  # Invalid character in body
+            "12345678-Z",    # Invalid check digit
+            "12..345.678-5", # Double dot
+        ]
+
+        for rut in invalid_ruts:
+            assert not pyrut.validate_rut(rut), f"RUT {rut} should be invalid"
+
+    def test_suspicious_ruts(self):
+        """Test suspicious RUTs (all same digits)"""
+        suspicious_ruts = [
+            "11111111-1",
+            "22222222-2",
+            "33333333-3",
+            "44444444-4",
+            "55555555-5",
+            "66666666-6",
+            "77777777-7",
+            "88888888-8",
+            "99999999-9"
+        ]
+
+        # Without suspicious flag, they should be valid
+        for rut in suspicious_ruts:
+            assert pyrut.validate_rut(rut, suspicious=False)
+
+        # With suspicious flag, they should be invalid
+        for rut in suspicious_ruts:
+            assert not pyrut.validate_rut(rut, suspicious=True)
+
+    def test_edge_cases(self):
+        """Test edge cases"""
+        # Minimum valid RUT
+        assert pyrut.validate_rut("1-9")
+
+        # RUT with spaces
+        assert pyrut.validate_rut(" 12.345.678-5 ")
+
+        # Mixed case K
+        assert pyrut.validate_rut("7654321k") == pyrut.validate_rut("7654321K")
+
+
+class TestFormatRut:
+    """Tests for format_rut function"""
+
+    def test_format_with_dots(self):
+        """Test formatting with dots enabled"""
+        test_cases = [
+            ("12345678-5", "12.345.678-5"),
+            ("123456785", "12.345.678-5"),
+            ("7654321K", "7.654.321-K"),
+            ("7654321k", "7.654.321-K"),
+            ("1234567-0", "1.234.567-0"),
+            ("12345-6", "12.345-6"),
+            ("123-4", "123-4"),
+            ("12-3", "12-3"),
+            ("1-9", "1-9")
+        ]
+
+        for input_rut, expected in test_cases:
+            result = pyrut.format_rut(input_rut, dots=True, uppercase=True)
+            assert result == expected, f"Format {input_rut} -> expected {expected}, got {result}"
+
+    def test_format_without_dots(self):
+        """Test formatting without dots"""
+        test_cases = [
+            ("12.345.678-5", "12345678-5"),
+            ("123456785", "12345678-5"),
+            ("7.654.321-K", "7654321-K"),
+            ("7654321k", "7654321-K")
+        ]
+
+        for input_rut, expected in test_cases:
+            result = pyrut.format_rut(input_rut, dots=False, uppercase=True)
+            assert result == expected, f"Format {input_rut} -> expected {expected}, got {result}"
+
+    def test_format_lowercase(self):
+        """Test formatting with lowercase K"""
+        test_cases = [
+            ("7654321K", "7.654.321-k"),
+            ("7654321k", "7.654.321-k"),
+            ("7.654.321-K", "7.654.321-k")
+        ]
+
+        for input_rut, expected in test_cases:
+            result = pyrut.format_rut(input_rut, dots=True, uppercase=False)
+            assert result == expected, f"Format {input_rut} -> expected {expected}, got {result}"
+
+    def test_format_combinations(self):
+        """Test all combinations of formatting options"""
+        input_rut = "7654321k"
+
+        # dots=True, uppercase=True
+        assert pyrut.format_rut(input_rut, dots=True, uppercase=True) == "7.654.321-K"
+
+        # dots=True, uppercase=False
+        assert pyrut.format_rut(input_rut, dots=True, uppercase=False) == "7.654.321-k"
+
+        # dots=False, uppercase=True
+        assert pyrut.format_rut(input_rut, dots=False, uppercase=True) == "7654321-K"
+
+        # dots=False, uppercase=False
+        assert pyrut.format_rut(input_rut, dots=False, uppercase=False) == "7654321-k"
+
+    
+
+
+class TestVerificationDigit:
+    """Tests for verification_digit function"""
+
+    def test_verification_digit_string(self):
+        """Test verification digit calculation with string input"""
+        test_cases = [
+            ("12345678", "5"),
+            ("11111111", "1"),
+            ("7654321", "6"),
+            ("1234567", "4"),
+            ("9999999", "3"),
+            ("1", "9"),
+            ("12", "4"),
+            ("123", "6")
+        ]
+
+        for rut_body, expected_dv in test_cases:
+            result = pyrut.verification_digit(rut_body)
+            assert result == expected_dv, f"VD for {rut_body} -> expected {expected_dv}, got {result}"
+
+    def test_verification_digit_int(self):
+        """Test verification digit calculation with integer input"""
+        test_cases = [
+            (12345678, "5"),
+            (11111111, "1"),
+            (7654321, "6"),
+            (1234567, "4"),
+            (9999999, "3"),
+            (1, "9"),
+            (12, "4"),
+            (123, "6")
+        ]
+
+        for rut_body, expected_dv in test_cases:
+            result = pyrut.verification_digit(rut_body)
+            assert result == expected_dv, f"VD for {rut_body} -> expected {expected_dv}, got {result}"
+
+    def test_verification_digit_edge_cases(self):
+        """Test edge cases for verification digit"""
+        # Test with very large numbers
+        large_num = 999999999
+        dv = pyrut.verification_digit(large_num)
+        assert isinstance(dv, str)
+        assert dv in "0123456789K"
+
+        # Test with zero
+        assert pyrut.verification_digit(0) in "0123456789K"
+
+    def test_verification_digit_invalid_input(self):
+        """Test verification digit with invalid input types"""
+        invalid_inputs = [
+            [],
+            {},
+            None,
+            3.14,
+            "abc"
+        ]
+
+        for invalid_input in invalid_inputs:
+            with pytest.raises((TypeError, ValueError)):
+                pyrut.verification_digit(invalid_input)
+
+
+class TestPydanticTypes:
+    """Tests for Pydantic type annotations"""
+
+    def test_rut_type_valid(self):
+        """Test Rut type with valid RUTs"""
+        from pydantic import BaseModel
+
+        class TestModel(BaseModel):
+            rut: Rut
+
+        valid_ruts = [
+            "11.111.111-8",
+            "12345678-5",
+            "7654321-6"
+        ]
+
+        for rut in valid_ruts:
+            model = TestModel(rut=rut)
+            assert model.rut == rut
+
+    def test_rut_type_invalid(self):
+        """Test Rut type with invalid RUTs"""
+        from pydantic import BaseModel
+
+        class TestModel(BaseModel):
+            rut: Rut
+
+        invalid_ruts = [
+            "11.111.111-2",
+            "invalid-rut",
+            "12345678-Z"
+        ]
+
+        for rut in invalid_ruts:
+            with pytest.raises(ValidationError):
+                TestModel(rut=rut)
+
+    def test_rut_not_suspicious_type(self):
+        """Test RutNotSuspicious type"""
+        from pydantic import BaseModel
+
+        class TestModel(BaseModel):
+            rut: RutNotSuspicious
+
+        # Valid non-suspicious RUT should work
+        model = TestModel(rut="12.345.678-5")
+        assert model.rut == "12.345.678-5"
+
+        # Suspicious RUT should fail
+        with pytest.raises(ValidationError):
+            TestModel(rut="11.111.111-1")
+
+
+class TestIntegration:
+    """Integration tests combining multiple functions"""
+
+    def test_format_and_validate_cycle(self):
+        """Test that formatted RUTs are still valid"""
+        test_ruts = [
+            "12345678-5",
+            "76543216",
+            "1234567-4"
+        ]
+
+        for rut in test_ruts:
+            # Format the RUT
+            formatted = pyrut.format_rut(rut, dots=True, uppercase=True)
+            # Validate the formatted RUT
+            assert pyrut.validate_rut(formatted), f"Formatted RUT {formatted} should be valid"
+
+    def test_verification_digit_integration(self):
+        """Test that calculated verification digits make valid RUTs"""
+        test_bodies = ["12345678", "7654321", "1234567"]
+
+        for body in test_bodies:
+            dv = pyrut.verification_digit(body)
+            full_rut = f"{body}-{dv}"
+            assert pyrut.validate_rut(full_rut), f"RUT {full_rut} with calculated DV should be valid"
+
+    def test_clean_and_validate(self):
+        """Test validation with various dirty inputs"""
+        dirty_ruts = [
+            "  12.345.678-5  ",
+            "12 345 678-5",
+            "12.345.678 - 5",
+            "12-345-678-5"
+        ]
+
+        for dirty_rut in dirty_ruts:
+            # Should either validate or fail gracefully
+            result = pyrut.validate_rut(dirty_rut)
+            assert isinstance(result, bool)
+
+
+class TestPerformance:
+    """Performance and stress tests"""
+
+    def test_validate_many_ruts(self):
+        """Test validation of many RUTs"""
+        # Generate test RUTs
+        test_ruts = []
+        for i in range(1000000, 1001000):  # 1000 RUTs
+            body = str(i)
+            dv = pyrut.verification_digit(body)
+            test_ruts.append(f"{body}-{dv}")
+
+        # Validate all RUTs
+        for rut in test_ruts:
+            assert pyrut.validate_rut(rut), f"Generated RUT {rut} should be valid"
+
+    def test_format_many_ruts(self):
+        """Test formatting of many RUTs"""
+        test_ruts = [f"1234567{i}-{pyrut.verification_digit(f'1234567{i}')}"
+                    for i in range(10)]
+
+        for rut in test_ruts:
+            formatted = pyrut.format_rut(rut, dots=True, uppercase=True)
+            assert isinstance(formatted, str)
+            assert len(formatted) > len(rut.replace(".", ""))  # Should be longer due to dots
